#!/bin/bash
# author: mcncm
#
# Setup script to run mongodb server and activate
# python environment. Runs mongodb on default
# port (27017) in the default directory for dysart's
# debug database (./debug_data/db)
#
# Run `$. config on` to start the debug database server
# and python environment and `$. config off` to turn
# them off.
#
# TODO: handle --help, -v, -q flags

DATETIME=`date '+%Y-%m-%d_%H:%M:%S'`
DB_NAME=debug_data
DB_PATH=./$DB_NAME/db
LOG_PATH=./$DB_NAME/log
DB_LOG_FILE=mongodb_$DATETIME.log
DYS_LOG_FILE=dysart.log
PYTHON_VERSION="3.7"
PYENV_NAME=dysenv
CONDA=1
VIRTUALENV=2
DB_OFF=0
DB_ON=1
ENV_OFF=0
ENV_ON=1
ENV_NEXIST=100
ENV_NO_MANAGER=101

#TODO: retrieve this list externally!
REQUIREMENTS={numpy,lmfit,pymongo,mongoengine,h5py,jsonschema,matplotlib}
CONDA_REQUIREMENTS={python.app,}

function echo_help {
	echo "Here are some dysart commands you can try out:"
	echo $'\t'"on"$'\t\t\t'"start python environment and database"
	echo $'\t'"off"$'\t\t\t'"stop python environment and database"
	echo $'\t'"help"$'\t\t\t'"this help page"
	echo $'\t'"status"$'\t\t\t'"the status of installed services"
	echo $'\t'"clean"
	echo $'\t\t'"env"$'\t\t'"remove python environment"
	echo $'\t\t'"db"$'\t\t'"clear database"
	echo $'\t\t'"log"$'\t\t'"clear log files"
	echo $'\t\t'"profile"$'\t\t'"remove modifications to bash profile"
	echo $'\t\t'"hard"$'\t\t'"all of the above"
	echo $'\t'"uninstall"$'\t\t'"the hardest clean"
}

function create_db {
	# If database location is missing, make it!
	if [[ ! -d $DYS_PATH/$DB_PATH ]]; then
		echo "Creating debug database..."
		mkdir -p $DYS_PATH/$DB_PATH
	fi

	# If database log is missing, make it!
	if [[ ! -d $DYS_PATH/$LOG_PATH ]]; then
		echo "Creating database log..."
		mkdir -p $DYS_PATH/$LOG_PATH
	fi
}

function find_env_manager {
	# Figure out how environments are managed.
	# Return a code for each manager type, with
	# preference from low to high.
	# conda: 1
	# virtualenv: 2

	CONDA_VERSION=`conda -V 2>/dev/null`
	VIRTUALENV_PATH=`which virtualenv`

	if [[ ! -z $CONDA_VERSION ]] ; then
		ENV_MANAGER=$CONDA
	elif [[ ! -z $VIRTUALENV_PATH ]] ; then
		ENV_MANAGER=$VIRTUALENV
	else
		ENV_MANAGER=0
	fi

	echo $ENV_MANAGER
}

function install_requirements {
	# Figure out how environments are managed;
	# Locate an install all required packages.
	# TODO: there are "correct" ways to do this
	# for each environment management tool, and
	# this is not one of them.
	ENV_MANAGER=`find_env_manager`
	# Note the redundancy here. This is because I
	# previously used two different solutions for each
	# manager, and a hint that I might again in the future.
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
		eval "conda install -y $CONDA_REQUIREMENTS"
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
	else
		echo "Unknown environment management tool. No packages to install."
	fi
}

function create_env {
	# Figure out how environments are managed;
	# Create the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		# Check whether Conda env exists. If not,
		# make one!
		if [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			activate_env
			echo "Creating python environment..."
			conda create -y -n $1 python=$PYTHON_VERSION
			deactivate_env
		fi
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]]; then
		if [[ ! -d $DYS_PATH/$1 ]] ; then
			activate_env
			echo "Creating python environment..."
			virtualenv $DYS_PATH/$1 --python=python$PYTHON_VERSION
			deactivate_env
		fi
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi

}

function activate_env {
	# Figure out how environments are managed;
	# Activate the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		echo "Activating python environment..."
		conda activate $1
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]]; then
		# Just activate the environment.
		echo "Activating python environment..."
		source $DYS_PATH/$1/bin/activate
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function deactivate_env {
	# Figure out how environments are managedl
	# Deactivate the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		echo "Deactivating python environment..."
		conda deactivate
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]] ; then
		echo "Deactivating python environment..."
		deactivate
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function env_get_status {
	# Checks if the python environment is activated.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		if [[ ! -z `conda info -e | grep \*.*$PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_ON
		elif [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_NEXIST
		else
			ENV_STATUS=$ENV_OFF
		fi
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]] ; then
		if [[ -d ./$PYENV_NAME ]] ; then
			if [[ ! -z `echo $VIRTUAL_ENV | grep $PYENV_NAME` ]] ; then
				ENV_STATUS=$ENV_ON
			else
				ENV_STATUS=$ENV_OFF
			fi
		else
			ENV_STATUS=$ENV_NEXIST
		fi	
	else
		ENV_STATUS=$ENV_NO_MANAGER
	fi	

	echo $ENV_STATUS
}

function db_get_status {
	# Checks if database server is already running.
	# Note the too-clever regex trick to filter out
	# a real mongod process without grep catching itself.
	if [[ ! -z `ps | grep "[m]ongo"` ]] ; then
		DB_STATUS=$DB_ON
	else
		DB_STATUS=$DB_OFF
	fi
	
	echo $DB_STATUS
}

function start_db {
	# Run the mongodb database
	DB_STATUS=`db_get_status`
	if [[ $DB_STATUS -eq $DB_OFF ]] ; then
		echo "Starting database on default port... "
		mongod --quiet --logpath $DYS_PATH/$LOG_PATH/$DB_LOG_FILE\
		 --dbpath $DYS_PATH/$DB_PATH &
		export MONGO_PID=$!
	else
		echo "Database already running."
	fi
}

function stop_db {
	# This doesn't work with MacOS/MongoDB:
	# mongod --shutdown --dbpath $DB_PATH
	DB_STATUS=`db_get_status`
	if [[ $DB_STATUS -eq 1 ]] ; then
		echo "Shutting down database server..."
		kill $MONGO_PID
		# Temporary safety feature
		sleep 1
	fi
}

function init_dys_log {
	# If the DySART logfile doesn't exist, make it!
	if [[ ! -f $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE ]] ; then
		touch $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE
	fi
}

function start {
	# Activate python environment; start db server
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -eq 1 ]] ; then
			echo ">>> Already on!"
			return 0
		fi
	fi
	activate_env $PYENV_NAME
	start_db
	init_dys_log
	export STARTED=1
}

function stop {
	# Deactivate python environment; stop db server
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -ne 0 ]] ; then
			# This doesn't work with MacOS MongoDB
			stop_db
			deactivate_env
			export STARTED=0
		fi
	else
		echo "Already off!"
	fi
}

function echo_status {
	# Prints status information on db server and python environment
	DB_STATUS=`db_get_status`
	ENV_STATUS=`env_get_status`
	# Print db server information
	if [[ $DB_STATUS -eq $DB_ON ]] ; then
		echo "database "$'\t'"ON"
	elif [[ $DB_STATUS -eq $DB_OFF ]] ; then
		echo "database"$'\t'"OFF"
	else
		echo "unknown database status"
	fi
	# Print python environment information
	if [[ $ENV_STATUS -eq $ENV_ON ]] ; then
		echo "$PYENV_NAME"$'\t\t'"ON"
	elif [[ $ENV_STATUS -eq $ENV_OFF ]] ; then
		echo "$PYENV_NAME"$'\t\t'"OFF"
	elif [[ $ENV_STATUS -eq $ENV_NEXIST ]] ; then
		echo "python environment does not exist"
	elif [[ $ENV_STATUS -eq $ENV_NO_MANAGER ]] ; then
		echo "no recognized python environment manager"
	else
		echo "unkown python environment status"
	fi
}

function clean {
	# Parse inputs to clean commant and pass
	# control to desired operation
	if [[ -z $1 ]] ; then
		clean_hard
	else
		case $1 in
			hard)		clean_hard	;;
			env)		clean_env	;;
			db)			clean_db 	;;
			database)	clean_db 	;;
			log)		clean_log	;;
			profile)	clean_profile	;;
			*)			echo "I don't understand that." ;;
		esac
	fi
}

function clean_hard {
	# Shut everything off
	stop
	# Clear environment and database
	clean_env
	clean_db
	clean_log
	clean_profile
}

function clean_env {
	# Delete python environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		echo "About to delete python environment $PYENV_NAME."
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			conda env remove -n $PYENV_NAME
		fi
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]] ; then
		PYENV_PATH=`pwd`/$PYENV_NAME
		echo "About to recursively delete directory $PYENV_PATH"
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			rm -rf $PYENV_NAME
		fi
	else
		echo "Unknown environment management tool. No known environment."
	fi
}

function clean_db {
	# Stop database server if necessary
	db_get_status
	if [[ $DB_STATUS -eq $DB_ON ]] ; then
		stop_db
	fi
	# Empty database directory.
	FULL_DB_PATH=$DYS_PATH/$DB_NAME/db
	echo "About to recursively empty directory $FULL_DB_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = "y" ]] ; then
		rm -rf $FULL_DB_PATH/*
	fi
	# Restart database server if it was previously shut off
	if [[ $DB_STATUS -eq $DB_ON ]] ; then
		start_db
	fi
}

function clean_log {
	# Stop database server
	stop_db
	# Empty log directory.
	FULL_LOG_PATH=$DYS_PATH/$DB_NAME/log
	echo "About to recursively empty directory $FULL_LOG_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = 'y' ]] ; then
		rm -rf $FULL_LOG_PATH/*
	fi
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "We get it, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function write_profile {
	# Aliases `dys` to . ./config
	# First argument should be full path to top-level directory
	PROFILE=$(get_profile)
	BASENAME=$(basename \`$PROFILE\`)
	if [[ ! $(cat $PROFILE | grep "dysart config") ]] ; then
		echo "Installer would like to modify your $BASENAME"
		read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
		if [[ $MOD_INPUT = 'y' ]] ; then
			CONTENT="# >>> dysart config >>>\n"
			CONTENT+="# Added by DySART installer\n"
			CONTENT+="alias dys=\". "$1"/config\"\n"
			CONTENT+="export DYS_PATH=$1\n"
			CONTENT+="# <<< dysart config <<<\n"
			echo -e $CONTENT"$(cat $PROFILE)" > $PROFILE
		fi
	fi
}

function clean_profile {
	PROFILE=$(get_profile)
	BASENAME=$(basename $PROFILE)
	echo "Installer would like to modify your $BASENAME"
	read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
	if [[ $MOD_INPUT = 'y' ]] ; then
		if [[ $OSTYPE == darwin* ]] ; then
			sed -i '' '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		elif [[ $OSTYPE == linux-gnu ]] ; then
			sed -i '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		else
			"Sorry, I'm not sure how to clean the profile in your OS."
		fi
	fi
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "yes, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function link_labber {
	# Set up labber installation for use with python environment
	# $1 is path to Labber installation
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER -eq $CONDA ]] ; then
		# Get the full true path to the conda environment
		FULL_ENV_PATH=`conda info -e | grep -o '/.*'$PYENV_NAME'$'`
		# Unlink. Don't use ln -f because its behavior is
		# platform-dependent (?)
		FULL_LINK_PATH=$FULL_ENV_PATH/lib/python$PYTHON_VERSION/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		# Link the labber installation
		ln -s $1/Script/Labber $FULL_LINK_PATH
	elif [[ $ENV_MANAGER -eq $VIRTUALENV ]] ; then
		FULL_LINK_PATH=./$PYENV_NAME/lib/python$PYTHON_VERSION/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		ln -s $1/Script/Labber $FULL_LINK_PATH
	else
		echo "Unknown environment management tool."
		echo "I'm not sure how to configure Labber."
	fi
}

# Note: unlink_labber isn't really necessary, since uninstall will erase
# whole python environment.

function install {
	# If not already installed,
	# write the dys alias to correct profile dotfile
	if [[ -z `type -t dys` ]] ; then
		PROFILE=$(get_profile)
		if [[ -z $(cat $PROFILE | grep dys) ]] ; then
			write_profile `pwd`
		fi
		source $PROFILE

		# Create python environment
		create_env $PYENV_NAME
		activate_env $PYENV_NAME
		install_requirements

		# Create database
		create_db
	fi
}

function uninstall {
	# Get rid of all the stuff the installation pollutes your system with.
	clean hard
	unalias dys
}


#####################
# SETUP SCRIPT BODY #
#####################

# Parse input to enter python environment and start db server
if [[ $# -ne 0 ]]; then
	case $1 in
		on)		start	;;
		start)	start	;;
		run)	start	;;
		go)		start	;;
		begin)	start	;;

		stop)	stop	;;
		end)	stop	;;
		quit)	stop	;;
		exit)	stop	;;
		finish)	stop	;;
		off) 	stop	;;

		help)	echo_help					;;
		status)	echo_status					;;
		
		install)	install					;;
		uninstall)	uninstall				;;
		clean)		clean $2				;;
		update)		install_requirements	;;
		upgrade)	install_requirements	;;

		labber) 	link_labber $2			;;
		Labber)		link_labber $2			;;

		*) echo "I don't understand that."	;;
	esac
else
	if [[ -z $(type -t dys ) ]] ; then
		# The first time it is run, do the installation!
		install
	else
		# Otherwise, print the help string
		echo_help
	fi

fi

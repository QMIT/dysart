#!/bin/bash
# author: mcncm
#
# Setup script to run mongodb server and activate
# python environment. Runs mongodb on default
# port (27017) in the default directory for dysart's
# debug database (./debug_data/db)
#
# Install by running `$ . config`.
# Run `$ dys on` to start the debug database server
# and python environment and `$ dys off` to turn
# them off.
#
# TODO: handle --help, -v, -q flags

DATETIME=`date '+%Y-%m-%d_%H:%M:%S'`
DB_NAME=debug_data
DB_PATH=$DB_NAME/db
LOG_PATH=$DB_NAME/log
DB_LOG_FILE=mongodb_$DATETIME.log
DB_CONNECT_SCRIPT_NAME=connect_db.py
DUMMY_LAB_SERVER=dummy_server.py
DYS_LOG_FILE=dysart.log
PYTHON_VERSION="3.7"
PYENV_NAME=dysenv
CONDA=conda
VIRTUALENV=virtualenv
DB_OFF=db_off
DB_ON=db_on
ENV_OFF=env_off
ENV_ON=env_on
ENV_NEXIST=env_nexist
ENV_NO_MANAGER=env_no_manager
LAB_OFF=lab_off
LAB_ON=lab_on

#TODO: retrieve this list externally!
REQUIREMENTS={numpy,lmfit,pymongo,mongoengine,h5py,jsonschema,matplotlib,pint}
CONDA_REQUIREMENTS={python.app,}
VIRTUALENV_REQUIREMENTS={}

# Regex for positive integers
integral='^[0-9]+$'

function echo_help {
	echo "Here are some dysart commands you can try out:"
	echo $'\t'"on"$'\t\t\t'"start python environment and database"
	echo $'\t'"off"$'\t\t\t'"stop python environment and database"
	echo $'\t'"restart"$'\t\t\t'"cycle the system: turn it off and on again"
	echo $'\t'"help"$'\t\t\t'"this help page"
	echo $'\t'"labber"$'\t\t\t'"link Labber to DySART"
	echo $'\t'"status"$'\t\t\t'"the status of installed services"
	echo $'\t'"clean"
	echo $'\t\t'"env"$'\t\t'"remove python environment"
	echo $'\t\t'"db"$'\t\t'"clear database"
	echo $'\t\t'"log"$'\t\t'"clear log files"
	echo $'\t\t'"profile"$'\t\t'"remove modifications to bash profile"
	echo $'\t\t'"hard"$'\t\t'"all of the above"
	echo $'\t'"uninstall"$'\t\t'"the hardest clean"
}

function create_db {
	# If database location is missing, make it!
	if [[ ! -d $DYS_PATH/$DB_PATH ]]; then
		echo "Creating debug database..."
		mkdir -p $DYS_PATH/$DB_PATH
	fi

	# If database log is missing, make it!
	if [[ ! -d $DYS_PATH/$LOG_PATH ]]; then
		echo "Creating database log..."
		mkdir -p $DYS_PATH/$LOG_PATH
	fi
}

function find_env_manager {
	# Figure out how environments are managed.
	# Return a code for each manager type, with
	# preference from low to high.
	# conda: 1
	# virtualenv: 2

	CONDA_VERSION=`conda -V 2>/dev/null`
	VIRTUALENV_PATH=`which virtualenv`

	if [[ ! -z $CONDA_VERSION ]] ; then
		ENV_MANAGER=$CONDA
	elif [[ ! -z $VIRTUALENV_PATH ]] ; then
		ENV_MANAGER=$VIRTUALENV
	else
		ENV_MANAGER=0
	fi

	echo $ENV_MANAGER
}

function install_requirements {
	# Figure out how environments are managed;
	# Locate an install all required packages.
	# TODO: there are "correct" ways to do this
	# for each environment management tool, and
	# this is not one of them.
	ENV_MANAGER=`find_env_manager`
	# Note the redundancy here. This is because I
	# previously used two different solutions for each
	# manager, and a hint that I might again in the future.
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
		eval "conda install -y $CONDA_REQUIREMENTS"
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
	else
		echo "Unknown environment management tool. No packages to install."
	fi
}

function create_env {
	# Figure out how environments are managed;
	# Create the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Check whether Conda env exists. If not,
		# make one!
		if [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			activate_env
			echo "Creating python environment..."
			conda create -y -n $1 python=$PYTHON_VERSION
			deactivate_env
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]]; then
		if [[ ! -d $DYS_PATH/$1 ]] ; then
			activate_env
			echo "Creating python environment..."
			virtualenv $DYS_PATH/$1 --python=python$PYTHON_VERSION
			deactivate_env
		fi
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi

}

function activate_env {
	# Figure out how environments are managed;
	# Activate the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		echo "Activating python environment..."
		conda activate $1
	elif [[ $ENV_MANAGER = $VIRTUALENV ]]; then
		# Just activate the environment.
		echo "Activating python environment..."
		source $DYS_PATH/$1/bin/activate
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function deactivate_env {
	# Figure out how environments are managedl
	# Deactivate the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		echo "Deactivating python environment..."
		conda deactivate
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		echo "Deactivating python environment..."
		deactivate
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function env_get_status {
	# Checks if the python environment is activated.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		if [[ ! -z `conda info -e | grep \*.*$PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_ON
		elif [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_NEXIST
		else
			ENV_STATUS=$ENV_OFF
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		if [[ -d $DYS_PATH/$PYENV_NAME ]] ; then
			if [[ ! -z `echo $VIRTUAL_ENV | grep $PYENV_NAME` ]] ; then
				ENV_STATUS=$ENV_ON
			else
				ENV_STATUS=$ENV_OFF
			fi
		else
			ENV_STATUS=$ENV_NEXIST
		fi
	else
		ENV_STATUS=$ENV_NO_MANAGER
	fi

	echo $ENV_STATUS
}

function db_get_status {
	# Checks if database server is already running.
	# Returns process id if it is.
	# Note the too-clever regex trick to filter out
	# a real mongod process without grep catching itself.
	PID=$(ps | grep "[m]ongo" | awk 'NR=1{print $1}')
	if [[ ! -z $PID ]] ; then
		DB_STATUS=$PID
	else
		DB_STATUS=$DB_OFF
	fi

	echo $DB_STATUS
}

function lab_get_status {
	# Checks if the dummy lab server is running.
	# If not, return the special $LAB_OFF signal.
	# If on, return its process id.
	RE="$(echo $DUMMY_LAB_SERVER | sed 's/^\(.\)/[\1]/')"
	PID=$(ps | grep "$RE" | awk 'NR=1{print $1}')
	if [[ -z $PID ]] ; then
		LAB_STATUS=$LAB_OFF
	else
		LAB_STATUS=$PID
	fi
	echo $LAB_STATUS
}

function start_db {
	# Run the mongodb database
	DB_STATUS=`db_get_status`
	if [[ $DB_STATUS = $DB_OFF ]] ; then
		echo "Starting database on default port... "
		mongod --quiet --logpath $DYS_PATH/$LOG_PATH/$DB_LOG_FILE\
		 --dbpath $DYS_PATH/$DB_PATH &
	# If DB_STATUS is a positive integer, it's a process id.
	# This could be considered bad practice leaking in, since db_get_status
	# doesn't have a single, well-defined return type.
	elif [[ $DB_STATUS =~ $integral ]] ; then
		echo "Database already running."
	fi

	# Write the db connect script literally, if it does not exist.
	CONNECT_SCRIPT_PATH=$DYS_PATH/$DB_NAME/$DB_CONNECT_SCRIPT_NAME
	if [[ ! -f $CONNECT_SCRIPT_PATH ]] ; then
		# Write connect script. This might be a little opaque, so keep tabs
		# on it and whether it needs to be documented properly.
		echo -e \
"import os, sys\n"\
"import mongoengine as me\n"\
"# Open a connection to the Mongo database\n"\
"host_data = ('localhost', 27017)\n"\
"me.connect('$DB_NAME',host=host_data[0],port=host_data[1])\n"\
"sys.path.pop(0)\n"\
"sys.path.insert(0,os.getcwd())\n"\
		>> $CONNECT_SCRIPT_PATH
	fi

	# Run python with database connection (safely!)
	if [[ -z $(alias | grep python) ]] ; then
		alias python="echo connecting to database server... &&
		python -q -i $CONNECT_SCRIPT_PATH"
	fi
}

function stop_db {
	# This doesn't work with MacOS/MongoDB:
	# mongod --shutdown --dbpath $DB_PATH
	DB_STATUS=`db_get_status`
	if [[ $DB_STATUS = $DB_OFF ]] ; then
		echo "Database already off."
	# Check to see if $DB_STATUS corresponds to a process id; if so, kill it.
	elif [[ $DB_STATUS =~ $integral ]] ; then
		echo "Shutting down database server..."
		kill $DB_STATUS
		# Temporary safety feature
		sleep 1
	fi
	if [[ ! -z $(alias | grep "python.*$DB_CONNECT_SCRIPT") ]] ; then
		unalias python
	fi
}

function start_lab {
	# Runs the dummy lab
	# find the actual full path to the binary! This is necessary because
	# we will alias `python` to connect to the database server.
	SERVER_SCRIPT=$DYS_PATH/dysart/measurement/$DUMMY_LAB_SERVER
	PYTHON_BINARY=`which python`
	echo "Starting dummy lab server..."
	$PYTHON_BINARY $SERVER_SCRIPT &
}

function stop_lab {
	LAB_STATUS=`lab_get_status`
	if [[ $LAB_STATUS =~ $numeric ]] ; then
		# LAB_STATUS is a process id
		echo "Shutting down dummy lab server..."
		kill $LAB_STATUS
	else
		echo "Dummy lab already off."
	fi
}

function init_dys_log {
	# If the DySART logfile doesn't exist, make it!
	if [[ ! -f $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE ]] ; then
		touch $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE
	fi
}

function start {
	# Activate python environment; start db server
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -eq 1 ]] ; then
			echo "Already on!"
			return 0
		fi
	fi
	activate_env $PYENV_NAME
	start_db
	start_lab
	init_dys_log
	export STARTED=1
}

function stop {
	# Deactivate python environment; stop db server
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -ne 0 ]] ; then
			# This doesn't work with MacOS MongoDB
			deactivate_env
			stop_db
			stop_lab
			export STARTED=0
		fi
	else
		echo "Already off!"
	fi
}

function restart {
	# Cycle the system
	stop
	start
}

function echo_status {
	# Prints status information on db server and python environment
	DB_STATUS=$(db_get_status)
	ENV_STATUS=$(env_get_status)
	LAB_STATUS=$(lab_get_status)
	# Print db server information
	if [[ $DB_STATUS =~ $integral ]] ; then
		echo "database "$'\t'"ON"
	elif [[ $DB_STATUS = $DB_OFF ]] ; then
		echo "database"$'\t'"OFF"
	else
		echo "unknown database status"
	fi
	# Print python environment information
	if [[ $ENV_STATUS = $ENV_ON ]] ; then
		echo "$PYENV_NAME"$'\t\t'"ON"
	elif [[ $ENV_STATUS = $ENV_OFF ]] ; then
		echo "$PYENV_NAME"$'\t\t'"OFF"
	elif [[ $ENV_STATUS = $ENV_NEXIST ]] ; then
		echo "python environment does not exist"
	elif [[ $ENV_STATUS = $ENV_NO_MANAGER ]] ; then
		echo "no recognized python environment manager"
	else
		echo "unkown python environment status"
	fi
	# Print dummy lab information
	if [[ $LAB_STATUS =~ $integral ]] ; then
		echo "dummy lab"$'\t'"ON"
	elif [[ $LAB_STATUS = $LAB_OFF ]] ; then
		echo "dummy lab"$'\t'"OFF"
	else
		echo "unknown dummy lab status"
	fi
}

function clean {
	# Parse inputs to clean commant and pass
	# control to desired operation
	if [[ -z $1 ]] ; then
		clean_hard
	else
		case $1 in
			hard)		clean_hard	;;
			env)		clean_env	;;
			db)			clean_db 	;;
			database)	clean_db 	;;
			log)		clean_log	;;
			profile)	clean_profile	;;
			*)			echo "I don't understand that." ;;
		esac
	fi
}

function clean_hard {
	# Shut everything off
	stop
	# Clear environment and database
	clean_env
	clean_db
	clean_log
	clean_profile
}

function clean_env {
	# Delete python environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		echo "About to delete python environment $PYENV_NAME."
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			conda env remove -n $PYENV_NAME
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		PYENV_PATH=`pwd`/$PYENV_NAME
		echo "About to recursively delete directory $PYENV_PATH"
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			rm -rf $PYENV_NAME
		fi
	else
		echo "Unknown environment management tool. No known environment."
	fi
}

function clean_db {
	# Stop database server if necessary
	db_get_status
	if [[ $DB_STATUS = $DB_ON ]] ; then
		stop_db
	fi
	# Empty database directory.
	FULL_DB_PATH=$DYS_PATH/$DB_NAME/db
	echo "About to recursively empty directory $FULL_DB_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = "y" ]] ; then
		rm -rf $FULL_DB_PATH/*
	fi
	# Restart database server if it was previously shut off
	if [[ $DB_STATUS = $DB_ON ]] ; then
		start_db
	fi
}

function clean_log {
	# Stop database server
	stop_db
	# Empty log directory.
	FULL_LOG_PATH=$DYS_PATH/$DB_NAME/log
	echo "About to recursively empty directory $FULL_LOG_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = 'y' ]] ; then
		rm -rf $FULL_LOG_PATH/*
	fi
	# Restart database server again
	start_db
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "We get it, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function write_profile {
	# Aliases `dys` to . ./config
	# First argument should be full path to top-level directory
	PROFILE=$(get_profile)
	BASENAME=$(basename \`$PROFILE\`)
	if [[ ! $(cat $PROFILE | grep "dysart config") ]] ; then
		echo "Installer would like to modify your $BASENAME"
		read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
		if [[ $MOD_INPUT = 'y' ]] ; then
			CONTENT="# >>> dysart config >>>\n"
			CONTENT+="# Added by DySART installer\n"
			CONTENT+="alias dys=\". "$1"/config\"\n"
			CONTENT+="export DYS_PATH=$1\n"
			CONTENT+="# <<< dysart config <<<\n"
			echo -e $CONTENT"$(cat $PROFILE)" > $PROFILE
		fi
	fi
}

function clean_profile {
	PROFILE=$(get_profile)
	BASENAME=$(basename $PROFILE)
	echo "Installer would like to modify your $BASENAME"
	read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
	if [[ $MOD_INPUT = 'y' ]] ; then
		if [[ $OSTYPE == darwin* ]] ; then
			sed -i '' '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		elif [[ $OSTYPE == linux-gnu ]] ; then
			sed -i '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		else
			"Sorry, I'm not sure how to clean the profile in your OS."
		fi
	fi
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "yes, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function link_labber {
	# Set up labber installation for use with python environment
	# $1 is path to Labber installation
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Get the full true path to the conda environment
		FULL_ENV_PATH=`conda info -e | grep -o '/.*'$PYENV_NAME'$'`
		# Unlink. Don't use ln -f because its behavior is
		# platform-dependent (?)
		FULL_LINK_PATH=$FULL_ENV_PATH/lib/python$PYTHON_VERSION/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		# Link the labber installation
		ln -s $1/Script/Labber $FULL_LINK_PATH
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		FULL_LINK_PATH=./$PYENV_NAME/lib/python$PYTHON_VERSION/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		ln -s $1/Script/Labber $FULL_LINK_PATH
	else
		echo "Unknown environment management tool."
		echo "I'm not sure how to configure Labber."
	fi
}

# Note: unlink_labber isn't really necessary, since uninstall will erase
# whole python environment.

function install {
	# If not already installed,
	# write the dys alias to correct profile dotfile
	if [[ -z `type -t dys` ]] ; then
		PROFILE=$(get_profile)
		if [[ -z $(cat $PROFILE | grep dys) ]] ; then
			write_profile `pwd`
		fi
		source $PROFILE

		# Create python environment
		create_env $PYENV_NAME
		activate_env $PYENV_NAME
		install_requirements

		# Create database
		create_db
	fi
}

function uninstall {
	# Get rid of all the stuff the installation pollutes your system with.
	clean hard
	unalias dys
}


#####################
# SETUP SCRIPT BODY #
#####################

# Parse input to enter python environment and start db server
if [[ $# -ne 0 ]]; then
	case $1 in
		on)		start	;;
		start)	start	;;
		run)	start	;;
		go)		start	;;
		begin)	start	;;

		stop)	stop	;;
		end)	stop	;;
		quit)	stop	;;
		exit)	stop	;;
		finish)	stop	;;
		off) 	stop	;;

		restart) restart				;;
		reboot) restart					;;
		cycle)  restart					;;

		help)	echo_help					;;
		status)	echo_status					;;

		install)	install					;;
		uninstall)	uninstall				;;
		clean)		clean $2				;;
		update)		install_requirements	;;
		upgrade)	install_requirements	;;

		labber) 	link_labber $2			;;
		Labber)		link_labber $2			;;

		*) echo "I don't understand that."	;;
	esac
else
	if [[ -z $(type -t dys ) ]] ; then
		# The first time it is run, do the installation!
		install
	else
		# Otherwise, print the help string
		echo_help
	fi

fi
